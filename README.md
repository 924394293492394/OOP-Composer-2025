# OOP-Composer-2025
изучение ООП. старт 22/05/2025

## План изучения:
### Подключение autoload
### Класс
### Свойства
### Методы
### Объекты
### Конструктор
### Наследование
### Уровни доступа
### Геттер
### Сеттер
### Абстрактный класс
### абстрактные методы
### Интерфейс
### Трейт
### (следующий) Принципы ООП
ООП — это парадигма программирования, основанная на концепции “объектов”, которые содержат данные (поля) и методы для работы с ними.
### Инкапсуляция
Смысл: Сокрытие внутренней реализации объекта и предоставление безопасного доступа через методы

Как реализуется:

Использование private полей.
Доступ через public геттеры/сеттеры.

Пример:

class Person {
    private String name;  // Поле скрыто

    public String getName() {  // Геттер
        return name;
    }

    public void setName(String name) {  // Сеттер
        if (name != null) {
            this.name = name;
        }
    }
}

Зачем?

Контроль над изменением данных (например, валидация в сеттере).
Гибкость (можно изменить внутреннюю логику без изменения кода снаружи).
### Наследование
Смысл: Создание новых классов на основе существующих (переиспользование кода).

Как реализуется:

Ключевое слово extends.
Класс-потомок наследует поля и методы родителя.

Пример:

class Animal {
    void eat() {
        System.out.println("Eating...");
    }
}

class Dog extends Animal {  // Dog наследует Animal
    void bark() {
        System.out.println("Barking...");
    }
}

Зачем?

Уменьшение дублирования кода.
Иерархическая организация классов.
### Полиморфизм
Смысл: Возможность использовать объекты разных классов через общий интерфейс.

Виды:

Перегрузка методов (compile-time) — один метод с разными параметрами.
Переопределение методов (runtime) — дочерний класс меняет поведение метода родителя.

Пример:

class Bird {
    void fly() {
        System.out.println("Flying...");
    }
}

class Penguin extends Bird {
    @Override
    void fly() {  // Переопределение метода
        System.out.println("Sorry, I can't fly!");
    }
}

public class Main {
    public static void main(String[] args) {
        Bird bird = new Penguin();  // Полиморфизм
        bird.fly();  // Вызовется переопределённый метод
    }
}

Зачем?

Гибкость кода (один интерфейс — множество реализаций).
Поддержка LSP (принцип подстановки Барбары Лисков).

Принцип подстановки Барбары Лисков:
Дочерние классы должны работать так, чтобы ими можно было заменить родительские.

Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP) утверждает, что поведение подклассов должно быть совместимо с поведением их суперклассов. Другими словами, объекты подтипов должны быть заменяемыми экземплярами своих супертипов без изменения ожидаемого поведения программы.
### Абстракция
Смысл: Сокрытие сложной реализации и предоставление упрощённого интерфейса.

Как реализуется:

Абстрактные классы (abstract class).
Интерфейсы (interface).
Пример:

abstract class Vehicle {
    abstract void start();  // Абстрактный метод
}

class Car extends Vehicle {
    @Override
    void start() {
        System.out.println("Car started!");
    }
}
Зачем?

Упрощение работы с сложными системами.
Определение контракта для классов.
### Магические методы
смотреть каталог magic_methods
### Методы для работы с объектами
## Дополнительно 23/05/2025
### Сериализация объектов
